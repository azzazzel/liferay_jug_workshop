package bg.jug.workshop.liferay.user.wrapper;

import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

import com.liferay.portal.kernel.util.StringPool;
import com.liferay.portal.kernel.util.Validator;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Reference;

import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.model.User;
import com.liferay.portal.kernel.model.UserGroup;
import com.liferay.portal.kernel.service.ServiceContext;
import com.liferay.portal.kernel.service.ServiceWrapper;
import com.liferay.portal.kernel.service.UserGroupLocalService;
import com.liferay.portal.kernel.service.UserLocalService;
import com.liferay.portal.kernel.service.UserLocalServiceWrapper;

/**
 * This is a service wrapper that wraps calls to methods in UserLocalService
 * We use it here to wrap the 
 * {@link UserLocalService#addUser(long, long, boolean, String, String, boolean, String, String, long, String, Locale, String, String, String, long, long, boolean, int, int, int, String, long[], long[], long[], long[], boolean, ServiceContext)}}
 * and 
 * {@link UserLocalService#addUserWithWorkflow(long, long, boolean, String, String, boolean, String, String, long, String, Locale, String, String, String, long, long, boolean, int, int, int, String, long[], long[], long[], long[], boolean, ServiceContext)}
 * methods to create 
 * <ul>
 * 	<li> create a user group if it does not exists</li>
 * 	<li> add the user being created to that user group if his domain is in {@code jug.bg} domain</li>
 * </ul>
 * 
 * <p> NOTE: The tricky part when writing wrappers is knowing which method(s) to wrap! For example there is also 
 * {@link UserLocalService#addUser(User)} method which is automatically generated by service builder 
 * but it is not used. Unfortunately there is no easy way to figure out which methods are used and which are not! 
 * 
 * <p> NOTE: One option to make it easier for people writing wrappers and calling service builder generated APIs
 * is to deprecate unused methods in {@code *LocalServiceImpl} classes and make them throw {@code UnsupportedOperationException}
 * See {@code TalkLocalServiceImpl#addTalk(Talk)} in {@code cfp/cfp-service} project for example. Unfortunately Liferay's
 * OOTB services do not do that.
 * 
 * @author Milen Dyankov
 */
@Component(
	immediate = true, 
	property = {}, 
	service = ServiceWrapper.class
)
public class AddUserToGroupWrapper extends UserLocalServiceWrapper {

	public AddUserToGroupWrapper() {
		super(null);
	}

	@Override
	public User addUser(long creatorUserId, long companyId, boolean autoPassword, String password1, String password2,
			boolean autoScreenName, String screenName, String emailAddress, long facebookId, String openId,
			Locale locale, String firstName, String middleName, String lastName, long prefixId, long suffixId,
			boolean male, int birthdayMonth, int birthdayDay, int birthdayYear, String jobTitle, long[] groupIds,
			long[] organizationIds, long[] roleIds, long[] userGroupIds, boolean sendEmail,
			ServiceContext serviceContext) throws PortalException {

		// massage the user group id list as necessary
		long[] updatedUserGroupIds = getUserGroupIds(emailAddress, companyId, userGroupIds, serviceContext);

		// add the user with the updated list
		return super.addUser(creatorUserId, companyId, autoPassword, password1, password2, autoScreenName,
				screenName, emailAddress, facebookId, openId, locale, firstName, middleName, lastName, prefixId,
				suffixId, male, birthdayMonth, birthdayDay, birthdayYear, jobTitle, groupIds, organizationIds, roleIds,
				updatedUserGroupIds, sendEmail, serviceContext);
	}

	@Override
	public User addUserWithWorkflow(long creatorUserId, long companyId, boolean autoPassword, String password1,
			String password2, boolean autoScreenName, String screenName, String emailAddress, long facebookId,
			String openId, Locale locale, String firstName, String middleName, String lastName, long prefixId,
			long suffixId, boolean male, int birthdayMonth, int birthdayDay, int birthdayYear, String jobTitle,
			long[] groupIds, long[] organizationIds, long[] roleIds, long[] userGroupIds, boolean sendEmail,
			ServiceContext serviceContext) throws PortalException {

		// massage the user group id list as necessary
		long[] updatedUserGroupIds = getUserGroupIds(emailAddress, companyId, userGroupIds, serviceContext);

		// add the user with the updated list
		return super.addUserWithWorkflow(creatorUserId, companyId, autoPassword, password1, password2,
				autoScreenName, screenName, emailAddress, facebookId, openId, locale, firstName, middleName, lastName,
				prefixId, suffixId, male, birthdayMonth, birthdayDay, birthdayYear, jobTitle, groupIds, organizationIds,
				roleIds, updatedUserGroupIds, sendEmail, serviceContext);
	}

	/**
	 * getUserGroupIds: Will return the array of user group ids to use.  The array might be modified from the original
	 * if the user should be added to the BG JUG user group.
	 *
	 * @param emailAddress Email address of the user being added.
	 * @param companyId Company the user is being added to.
	 * @param userGroupIds Current array of user group ids.
	 * @param serviceContext Service context to use for service activity.
	 * @return long array of user group ids to persist.
	 */
	protected long[] getUserGroupIds(final String emailAddress, final long companyId, final long[] userGroupIds, final ServiceContext serviceContext) throws PortalException {
		if (Validator.isNotNull(emailAddress)) {
			// we have an email address, is it one that we are worried about?

			if (emailAddress.endsWith(JUG_BG_EMAIL_SUFFIX)) {
				// this is a user that should be in our user group, find the id
				long bgjugUserGroupId = getUserGroupId(companyId, serviceContext);

				// check if the incoming user group id array already contains the BG JUG user group id.
				if ((userGroupIds != null) && (userGroupIds.length > 0)) {
					for (long userGroupId : userGroupIds) {
						if (bgjugUserGroupId == userGroupId) {
							// already in the array, just return the original array
							return userGroupIds;
						}
					}
				}

				// not in the array, we need to add the BG JUG user group id to the array.

				if ((userGroupIds == null) || (userGroupIds.length < 1)) {
					// easy case, there wasn't an incoming array
					return new long[] { bgjugUserGroupId };
				}

				// need an updated array
				long[] updatedUserGroupIds = new long[userGroupIds.length + 1];

				// copy in the originals
				for (int idx = 0; idx < userGroupIds.length; idx++) {
					updatedUserGroupIds[idx] = userGroupIds[idx];
				}

				// add the BG JUG user group id
				updatedUserGroupIds[userGroupIds.length] = bgjugUserGroupId;

				// return the updated list
				return updatedUserGroupIds;
			}
		}

		// if we get here, email address doesn't match, user group array already includes the id, etc.
		// just return the original array.

		return userGroupIds;
	}

	/**
	 * getUserGroupId: Looks up the user group id for the target group, will cache the value so we don't repeat
	 * the lookups.
	 * @param companyId Company id to get the user group from.
	 * @param serviceContext The service context used to add a new user group if it doesn't already exist.
	 * @return long The user group id.
	 */
	protected long getUserGroupId(final long companyId, final ServiceContext serviceContext) throws PortalException {
		Long userGroupId = _bgjugTeamUserGroupIdMap.get(companyId);

		if (Validator.isNotNull(userGroupId)) {
			// have a cached value, let's use it.

			return userGroupId;
		}

		// not yet in the cache, try to get the entity

		/*
		 * There are always 2 methods in every `*LocalService` for obtaining entities by id:
		 * - fetch*(...) - which returns `null` if the entity is not found
		 * - get*(...) - which throws an exception if the entity is not found
		 */
		UserGroup userGroup = _userGroupLocalService.fetchUserGroup(companyId, BGJUG_TEAM_GROUP_NAME);

		if (Validator.isNull(userGroup)) {
			// doesn't already exist, let's create it.

			userGroup = _userGroupLocalService.addUserGroup(
					serviceContext.getUserId(), 	// the id of the user group
					companyId,	                    // the id of the instance (useful in mutli-tenant environment)
					BGJUG_TEAM_GROUP_NAME,			// the name of the user group
					StringPool.BLANK,				// the description of the user group
					serviceContext					// the context of the service request
			);
		}

		// save the id in the cache
		_bgjugTeamUserGroupIdMap.put(companyId, userGroup.getUserGroupId());

		// return it
		return userGroup.getUserGroupId();
	}

	/**
	 * BGJUG_TEAM_GROUP_NAME: Constant to hold the desired user group name.
	 */
	public static final String BGJUG_TEAM_GROUP_NAME = "BGJUG Team";

	/**
	 * JUG_BG_EMAIL_SUFFIX: Constant to hold the email suffix that we are checking.
	 */
	public static final String JUG_BG_EMAIL_SUFFIX = "jug.bg";

	@Reference
	protected void setUserGroupLocalService(final UserGroupLocalService userGroupLocalService) {
		_userGroupLocalService = userGroupLocalService;
	}

	private UserGroupLocalService _userGroupLocalService;
	private Map<Long, Long> _bgjugTeamUserGroupIdMap = new HashMap<>();
}